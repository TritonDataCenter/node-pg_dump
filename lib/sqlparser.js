/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2016 Joyent, Inc.
 */

/*
 * SQL Parsing Routines
 *
 * This file contains extremely basic support for a handful of specific SQL
 * commands that appear in PostgreSQL backup files, as generated by the
 * "pg_dump" program.
 */

var mod_assert = require('assert-plus');
var mod_verror = require('verror');

var VE = mod_verror.VError;

/*
 * This list was based on the list of SQL commands in "VI. Reference" of the
 * PostgreSQL 9.2.18 documentation.  Key words that may be the first name in a
 * command have the value true.  Note that PostgreSQL normalises to lower case
 * all names that are not quoted identifiers.
 */
var PREFIX_KEYWORDS = {
	'abort': true,
	'alter': true,
	'analyze': true,
	'begin': true,
	'checkpoint': true,
	'close': true,
	'cluster': true,
	'comment': true,
	'commit': true,
	'copy': true,
	'create': true,
	'deallocate': true,
	'declare': true,
	'delete': true,
	'discard': true,
	'do': true,
	'drop': true,
	'end': true,
	'execute': true,
	'explain': true,
	'fetch': true,
	'grant': true,
	'insert': true,
	'listen': true,
	'load': true,
	'lock': true,
	'move': true,
	'notify': true,
	'prepare': true,
	'reassign': true,
	'reindex': true,
	'release': true,
	'reset': true,
	'revoke': true,
	'rollback': true,
	'savepoint': true,
	'security': true,
	'select': true,
	'set': true,
	'show': true,
	'start': true,
	'stderr': true,
	'stdin': true,
	'stdout': true,
	'truncate': true,
	'unlisten': true,
	'update': true,
	'vacuum': true,
	'values': true,
};

/*
 * Determine whether this name is a valid initial key word for a SQL command.
 */
function
valid_initial_keyword(nam)
{
	if (PREFIX_KEYWORDS[nam.toLowerCase()])
		return (true);

	return (false);
}

/*
 * Take a list of tokens from SQLTokeniser and attempt to parse them as a
 * command.  If the command begins with a key word that we recognise, but for a
 * command that we cannot parse, we return null.  If there is a parsing error,
 * a VError is returned describing the fault.
 */
function
parse_command(cmd)
{
	mod_assert.arrayOfObject(cmd, 'cmd');

	if (cmd.length < 1) {
		/*
		 * An empty statement.
		 */
		return (null);
	}

	/*
	 * A command should begin with an unquoted name.
	 */
	if (cmd[0].t !== 'name') {
		return (VE('command did not start with an unquoted name'));
	}

	/*
	 * A command should begin with one of the key words known to be
	 * the start of a valid PostgreSQL command.
	 */
	var vv = cmd[0].v.toLowerCase();
	if (!valid_initial_keyword(vv)) {
		return (VE('invalid key word "%s"', vv));
	}

	var ret, msg;
	switch (vv) {
	case 'copy':
		msg = 'parsing COPY command';
		ret = parse_command_copy(cmd);
		break;

	default:
		/*
		 * We don't currently know how to parse this particular
		 * command.
		 */
		return (null);
	}

	if (ret instanceof Error) {
		ret = VE(ret, msg);
	}

	return (ret);
}

/*
 * Parse a COPY comamnd.
 *
 * As per the PostgreSQL 9.2 documentation, a COPY statement has the following
 * structure:
 *
 *	COPY table_name [ ( column_name [, ...] ) ]
 *		FROM { 'filename' | STDIN }
 *		[ [ WITH ] ( option [, ...] ) ]
 * 
 *	COPY { table_name [ ( column_name [, ...] ) ] | ( query ) }
 *		TO { 'filename' | STDOUT }
 *		[ [ WITH ] ( option [, ...] ) ]
 * 
 *	where option can be one of:
 * 
 *		FORMAT format_name
 * 		OIDS [ boolean ]
 * 		DELIMITER 'delimiter_character'
 * 		NULL 'null_string'
 * 		HEADER [ boolean ]
 * 		QUOTE 'quote_character'
 * 		ESCAPE 'escape_character'
 * 		FORCE_QUOTE { ( column_name [, ...] ) | * }
 * 		FORCE_NOT_NULL ( column_name [, ...] )
 * 		ENCODING 'encoding_name'
 *
 * At present, we support only a limited subset of the COPY command.  Any
 * deviation from that subset will result in a parsing error.  The allowed
 * subset is:
 *
 *	COPY table_name ( column_name [, ...] ) FROM STDIN
 *
 * If parsing was successful, an object describing the COPY statement is
 * returned:
 *
 *	{
 *		"command": "copy",
 *		"table_name": "...",
 *		"column_names": [ "...", ... ],
 *		"delimiter": "\t",
 *		"format": "text",
 *		"null_string": "\\N"
 *	}
 */
function
parse_command_copy(cmd)
{
	mod_assert.arrayOfObject(cmd, 'cmd');
	mod_assert.ok(cmd.length > 0, 'cmd.length > 0');
	mod_assert.strictEqual(cmd[0].t, 'name', 'must be a name');
	mod_assert.strictEqual(cmd[0].v.toLowerCase(), 'copy',
	    'must be a COPY command');

	var state = 'TABLE_NAME';
	var table_name = null;
	var column_names = [];

	for (var i = 1; i < cmd.length; i++) {
		var t = cmd[i].t;
		var v = cmd[i].v;
		var vv = cmd[i].v.toLowerCase();

		switch (state) {
		case 'TABLE_NAME':
			if (t === 'quoted_name') {
				table_name = v;
			} else if (t === 'name') {
				if (valid_initial_keyword(vv)) {
					return (VE('invalid table name "%s"',
					    v));
				}
				table_name = vv;
			} else {
				return (VE('expected a table name'));
			}
			state = 'OPEN_PARENS';
			break;

		case 'OPEN_PARENS':
			if (t !== 'special' || v !== '(') {
				return (VE('expected column name list'));
			}
			state = 'COLUMN_NAME';
			break;

		case 'COLUMN_NAME':
			var cnt = null;
			if (t === 'quoted_name') {
				cnt = v;
			} else if (t === 'name') {
				if (valid_initial_keyword(vv)) {
					return (VE('invalid column name "%s"',
					    v));
				}
				cnt = vv;
			} else if (t === 'special' && v === ')') {
				state = 'FROM';
				break;
			} else {
				return (VE('expected a column name'));
			}
			if (column_names.indexOf(cnt) !== -1) {
				return (VE('duplicate column name "%s"', cnt));
			}
			column_names.push(cnt);
			state = 'COMMA';
			break;

		case 'COMMA':
			if (t === 'special' && v === ',') {
				state = 'COLUMN_NAME';
			} else if (t === 'special' && v === ')') {
				state = 'FROM';
			} else {
				return (VE('invalid column name list'));
			}
			break;

		case 'FROM':
			if (t !== 'name' || vv !== 'from') {
				return (VE('expected key word FROM'));
			}
			state = 'FROM_WHERE';
			break;

		case 'FROM_WHERE':
			if (t !== 'name' || vv !== 'stdin') {
				return (VE('only STDIN source is supported'));
			}
			return ({
				command: 'copy',
				table_name: table_name,
				column_names: column_names,
				delimiter: '\t',
				format: 'text',
				null_string: '\\N'
			});

		default:
			throw (VE('invalid SQL parser state: %s', state));
		}
	}

	return (VE('incomplete or invalid SQL command'));
}


module.exports = {
	parse_command: parse_command
};
/* vim: set ts=8 sts=8 sw=8 noet: */
